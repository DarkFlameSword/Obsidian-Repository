# Q1
## a
$$\phi_1 = (((A ∨ (B → C)) ∧ (¬C ∨ D)) → ((A → D) ∨ (C ↔ E)))$$
**Conclusion:**
satisfiable but not valid

**Justification:**
- if `A = true, D = true`, then the equivalence holds
- if `A = true, D = false, C = false, E =true`, then the equivalence fails

---

$$\phi_2 = (((¬A ∧ B) ∨ (C → D)) ∧ (¬E ∨ A)) → ((¬D ∨ F) ↔ (A ∧ B))$$
**Conclusion:**
satisfiable but not valid

**Justification:**
- If `A = true, B = true, D = false, F = false`, the equivalence fails
- If `A = true, B = true, D = false, F = true`, the equivalence holds

---

$$\phi_3 = ((A ↔ B) ∨ (C → D)) ∧ ((¬A ∨ ¬D) → (F ∧ ¬G))$$
**Conclusion:**
satisfiable but not valid

**Justification:**
- If `A = true, D = false`, the equivalence fails
- If `F = true, G = false`, the equivalence holds

---
## b

$$\phi_1 = (((A ∨ (B → C)) ∧ (¬C ∨ D)) → ((A → D) ∨ (C ↔ E)))$$
**Converting CNF steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: 
$$\lnot \left( \left[ A \lor (\lnot B \lor C) \right] \land (\lnot C \lor D) \right) \lor \left( (\lnot A \lor D) \lor \left[ (\lnot C \land E) \lor ( C \land \lnot E) \right] \right)$$
2. CNF: 
$$\begin{aligned}
&φ₁ = [¬(A ∨ ¬B ∨ C) ∨ ¬(¬C ∨ D)] ∨ [(¬A ∨ D ∨ ¬C ∨ E) ∧ (¬A ∨ D ∨ ¬E ∨ C)]\\
&φ₁ = [(¬A ∧ B ∧ ¬C) ∨ (C ∧ ¬D)] ∨ [(¬A ∨ D ∨ ¬C ∨ E) ∧ (¬A ∨ D ∨ ¬E ∨ C)]\\\\

& \text{if we assume:}\\
& A₁ = (¬A ∧ B ∧ ¬C) ∨ (C ∧ ¬D)\\
& B₁ = (¬A ∨ D ∨ ¬C ∨ E)\\
& B₂ = (¬A ∨ D ∨ ¬E ∨ C)\\
& \text{So we have:}\; φ₁ = A₁ ∨ (B₁ ∧ B₂)\\\\
& \text{Using the distributive law:}\; φ₁ = (A₁ ∨ B₁) ∧ (A₁ ∨ B₂)\\
& φ₁ = [((¬A ∧ B ∧ ¬C) ∨ (C ∧ ¬D)) ∨ (¬A ∨ D ∨ ¬C ∨ E)] ∧\\
& [((¬A ∧ B ∧ ¬C) ∨ (C ∧ ¬D)) ∨ (¬A ∨ D ∨ ¬E ∨ C)]\\\\

& φ₁ = [((¬A ∧ B ∧ ¬C) ∨ (C ∧ ¬D)) ∨ (¬A ∨ D ∨ ¬C ∨ E)] ∧\\
& [((¬A ∧ B ∧ ¬C) ∨ (C ∧ ¬D)) ∨ (¬A ∨ D ∨ ¬E ∨ C)]\\\\\\

& \text{Final CNF Result:}φ₁ = (¬A ∨ B ∨ D ∨ E) ∧ (¬A ∨ D ∨ ¬E ∨ C) ∧ (¬A ∨ ¬C ∨ E)
\end{aligned}$$
**Horn clauses identification:**
1. (¬A ∨ ¬C ∨ E) is Horn clause (contains only one positive literals)

---

$$\phi_2 = (((¬A ∧ B) ∨ (C → D)) ∧ (¬E ∨ A)) → ((¬D ∨ F) ↔ (A ∧ B))$$
**Converting CNF steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: 
$$\begin{aligned}
& φ₂ = (((¬A ∧ B) ∨ (¬C ∨ D)) ∧ (¬E ∨ A)) → \\
& (((¬D ∨ F) → (A ∧ B)) ∧ ((A ∧ B) → (¬D ∨ F)))\\\\

&φ₂ = ¬(((¬A ∧ B) ∨ (¬C ∨ D)) ∧ (¬E ∨ A)) ∨ \\
&(((D ∧ ¬F) ∨ (A ∧ B)) ∧ (¬A ∨ ¬B ∨ ¬D ∨ F))\\
\end{aligned}$$
2. CNF: 
$$\begin{aligned}
& \text{Using the De Morgan's law:}\\
& φ₂ = (((A ∨ ¬B) ∧ (C ∧ ¬D)) ∨ (E ∧ ¬A)) ∨ \\
& (((D ∧ ¬F) ∨ (A ∧ B)) ∧ (¬A ∨ ¬B ∨ ¬D ∨ F)) \\\\

& \text{Using the distributive law:}\\
& [(A ∨ ¬B ∨ E) ∧ (A ∨ ¬B ∨ ¬A) ∧ (C ∨ E) ∧ (C ∨ ¬A) ∧ (¬D ∨ E) ∧ (¬D ∨ ¬A)] ∨\\
& [(D ∨ A) ∧ (D ∨ B) ∧ (¬F ∨ A) ∧ (¬F ∨ B) ∧ (¬A ∨ ¬B ∨ ¬D ∨ F)]\\\\

& \text{Final CNF Result:}\\
& φ₂ = (A ∨ ¬B ∨ E ∨ D) ∧ (A ∨ E ∨ D ∨ B) ∧ (A ∨ ¬B ∨ E ∨ ¬F) ∧ \\
& (A ∨ E ∨ ¬F ∨ B) ∧ (¬B ∨ E ∨ ¬A ∨ ¬D ∨ F) ∧\\
& (C ∨ E ∨ D ∨ A) ∧ (C ∨ E ∨ D ∨ B) ∧ (C ∨ E ∨ ¬F ∨ A) ∧ \\
& (C ∨ E ∨ ¬F ∨ B) ∧ (C ∨ E ∨ ¬A ∨ ¬B ∨ ¬D ∨ F) ∧\\
& (C ∨ D) ∧ (C ∨ ¬A ∨ D ∨ B) ∧ (C ∨ ¬F) ∧ \\
& (C ∨ ¬A ∨ ¬F ∨ B) ∧ (C ∨ ¬A ∨ ¬B ∨ ¬D ∨ F) ∧\\
& (E ∨ A) ∧ (E ∨ D ∨ B) ∧ (¬D ∨ E ∨ ¬F ∨ A) ∧ \\
& (¬D ∨ E ∨ ¬F ∨ B) ∧ (E ∨ ¬A ∨ ¬B ∨ ¬D ∨ F) ∧\\
& (¬A ∨ D) ∧ (¬D ∨ ¬A ∨ D ∨ B) ∧ (¬A ∨ ¬F) ∧\\ 
& (¬D ∨ ¬A ∨ ¬F ∨ B) ∧ (¬A ∨ ¬B ∨ ¬D ∨ F)\\
\end{aligned}$$
**Horn clauses identification:**
1. (C ∨ ¬F) is Horn clause (contains only one positive literals)
2. (¬A ∨ D) is Horn clause (contains only one positive literals)
3. (¬A ∨ ¬F) is Horn clause (contains only one positive literals)
4. (¬D ∨ ¬A ∨ ¬F ∨ B) is Horn clause (contains only one positive literals)
5. (¬A ∨ ¬B ∨ ¬D ∨ F) is Horn clause (contains only one positive literals)


---

$$\phi_3 = ((A ↔ B) ∨ (C → D)) ∧ ((¬A ∨ ¬D) → (F ∧ ¬G))$$
**Converting CNF steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: 
$$\begin{aligned}
φ₃ = [((¬A ∨ B) ∧ (¬B ∨ A)) ∨ (¬C ∨ D)] ∧ [(A ∧ D) ∨ (F ∧ ¬G)]
\end{aligned}$$
2. CNF: 
$$\begin{aligned}
& \text{Using the distributive law:}\\
& (¬A ∨ B ∨ ¬C ∨ D) ∧ (¬B ∨ A ∨ ¬C ∨ D) ∧ (A ∨ F) ∧ (A ∨ ¬G) ∧ (D ∨ F) ∧ (D ∨ ¬G)\\\\

& \text{Final CNF Result:}\\
& φ₃ = (¬A ∨ B ∨ ¬C ∨ D) ∧
(¬B ∨ A ∨ ¬C ∨ D) ∧(A ∨ F) ∧(A ∨ ¬G) ∧(D ∨ F) ∧(D ∨ ¬G)
\end{aligned}$$
**Horn clauses identification:**
1. (A ∨ ¬G) is Horn clause (contains only one positive literals)
2. (D ∨ ¬G) is Horn clause (contains only one positive literals)

---
## c

---
### i
- Right side: `(¬D ∨ F) ↔ (A ∧ B)`
- With `F = false`: becomes `(¬D) ↔ (A ∧ B)`
- This enforces a strong dependency: if `A ∧ B` is true, then `¬D` must be true
- Satisfiability is still possible, but restricted

---
### ii
- If `A ∧ B = true`, then `D = false`
- If `A ∧ B = false`, then `D = true`
- So the truth of `(A ∧ B)` directly controls `D`
- Cannot infer `A` or `B` individually, only about their conjunction

---
# Q2
## Q2.1
$$\begin{aligned}
&R1: (P \land T \land NS) \to S\\
&R2: F \to H\\
&R3: H \to T\\
&R4: E \to NS\\
&R5: NS \to P\\
&R6: P \to W\\
&R7: M \to NF\\
&R8: \text{(no symbol for "sneeze in spring" in key) → ignored  } \to A\\
&R9: (\lnot T \land \lnot NS) \to (\lnot V \lor W)\\
&R10: (\lnot E \land \lnot T) \to (\lnot NF \lor W)\\
\end{aligned}
$$

---
## Q2.2
Initial facts (observations): 
- The person has a fever
- The person is exhausted

Prove that the person is sick (S):
- $F \; proves \; H \rightarrow TruthList[F,E,H]$
- $H \; proves \; T \rightarrow TruthList[F,E,H,T]$
- $E \; proves \; NS \rightarrow TruthList[F,E,H,T,NS]$
- $NS \; proves \; P \rightarrow TruthList[F,E,H,T,NS,P]$
- $T,NS,P \;proves\; S$
- $so\; F \land E \;proves\;S$

---
## Q2.3
Initial facts (observations): 
- The person has a fever
- The person is exhausted

Prove that the person is sick (S):
- $Goal\; S \; needs \; [P,T,NS] \rightarrow NeedList[P,T,NS]$
- $P \; needs \; NS \rightarrow NeedList[T,NS]$
- $NS \; needs \; E \rightarrow NeedList[T,E]$
- $T \; needs \; H \rightarrow NeedList[H,E]$
- $H \; needs \; F \rightarrow NeedList[F,E]$
- $\text{we already know [F,E], so we can infer S}$

---
## Q2.4
### i
Answer: 
- Yes, forward chaining can stop early if the algorithm is goal-directed or implemented to terminate when the target atom S is derived. In our run, forward chaining derived S after a finite number of rule applications (R2,R3,R4,R5,R1). Once S is derived, there is no need to continue deriving other consequences (like W from R6). If using a blind saturation strategy (derive all consequences until fixpoint), it would not stop early; but typical forward-chaining provers stop when the goal is reached.

### ii
Answer:
- Adding `\lnot M` (i.e. asserting the person does NOT have muscle pain) would only block inferences that require M. Rule R7 is M -> NF (muscle pain implies not feeling well). If we add `\lnot M`, that prevents deriving NF via R7, but R7 was not needed for deriving S in this scenario. Thus adding `\lnot M` does not help derive S; it only prevents derivation of NF from M, and thus generally does not improve inference toward S.

- Adding `A` (the person has an allergy) corresponds to the allergy atom. The only rule mentioning A in the provided rules is R8 (which depends on a sneeze-in-spring atom that we do not have). There are no rules that use A to derive P, T, NS, or S. So adding `A` alone does not help infer S.

Conclusion: Neither `\lnot M` nor `A` would improve the ability to infer `S` in the current KB — they are irrelevant to the chain of rules that lead to `S`.

---
# Q3
## a
$$∃z. R(z) → ∃w. T(w)$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$

$$∀x ∃y. ( ∀z. (P(x) ∨ R(z))  ∧  ∃w. (T(w) → Q(y)) )
$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$

$$∀w ∃y. ( ∀x. (P(x) → T(w))  ∧  ∀x. (Q(y) → P(x)) )
$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$

$$∀x ∃z. (¬R(z) ∨ ¬Q(x))
$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$

$$∀x. ( U(x) → (P(x) ∨ ¬T(f(x))) )
$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$

$$∃x. ( Q(x) ∧ ¬U(x) )
$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$

$$∀x ∀y. (¬P(x) ∨ Q(y) ∨ S(x,y))
$$
**Converting steps:**
1. eliminate $\rightarrow \text{and} \leftrightarrow$: $s$
2. NNF: 
3. Skolem: $d$


---
## b
**Step 1 — instantiate Clause 4 using `x = a`**

`C4[x := a]:  ¬R(f4(a)) ∨ ¬Q(a)`

**Step 2 — use fact `Q(a)` (C6a) and resolve with C4[x:=a]**

Resolve `¬Q(a)` with `Q(a)`:

`Resolve( C4[x:=a], C6a )  =>  ¬R(f4(a))`

Call this derived clause:

`D1:  ¬R(f4(a))`

**Step 3 — instantiate Clause 2a with `z := f4(a)` (and arbitrary `x`)**

Clause `C2a` is `P(x) ∨ R(z)`. Substitute `z := f4(a)`:

`C2a[z := f4(a)]:  P(x) ∨ R(f4(a))`

**Step 4 — resolve `C2a[z:=f4(a)]` with `D1`**

Resolve on `R(f4(a))` / `¬R(f4(a))`:

`Resolve( P(x) ∨ R(f4(a)),  ¬R(f4(a)) )  =>  P(x)`

This yields `P(x)` for arbitrary `x`. In particular, instantiate `x := b` to get:

`D2:  P(b)`

**Step 5 — resolve `D2` with the negated goal `Cneg`**

`Resolve( P(b),  ¬P(b) )  =>  ⊥   (empty clause)`

We have derived a contradiction. Therefore the negation of the goal is unsatisfiable with the knowledge base; hence **the KB entails `∀x P(x)`**.

**Conclusion (part b):** Using resolution on the CNF set above, we can prove `∀x P(x)` (the resolution refutation succeeds).

---
## c
### i
A clause is _redundant_ if it can be derived from other clauses (or its removal does not affect provability of the goal).

- **C7 (`¬P(x) ∨ Q(y) ∨ S(x,y)`)** is _not needed_ for the derivation above; the proof did not use `S` or clause `C7`. So `C7` is redundant **with respect to proving** `∀x P(x)`.
    
- **C3a (`¬P(x) ∨ T(w)`)** and **C3b (`¬Q(f3(w)) ∨ P(x)`)** were also not used in the short refutation above. Depending on the rest of KB semantics, some of these may be redundant for the specific goal. In particular, we did not need `C3b` or `C3a` in the derivation.
    
- **C1 (`¬R(x) ∨ T(c1)`)** and **C2b (`¬T(g2(x)) ∨ Q(f2(x))`)** were also not required in the minimal proof given. So for the particular proof of `∀x P(x)`, these clauses are effectively redundant.

### ii
Clauses that increase complexity generally are those that:

- introduce many variables or arities (e.g. clauses with two universal variables like `C7: ¬P(x) ∨ Q(y) ∨ S(x,y)`), and
    
- introduce Skolem **functions** (not just constants), which generate infinitely many ground terms under instantiation — e.g. `f2(x)`, `g2(x)`, `f3(w)`, and `f4(x)`.
    

Concretely:

- **Clauses with Skolem functions** (`C2b`, `C3b`, `C4`) increase search-space complexity because resolution can create many different ground instances with terms like `f2(t)`, `g2(t)`, `f3(t)`, `f4(t)` for many `t`.
    
    - `C2b: ¬T(g2(x)) ∨ Q(f2(x))` and `C3b: ¬Q(f3(w)) ∨ P(x)` are particularly problematic because they chain function terms and can cause a combinatorial explosion in unification/instantiation.
        
- **Clause 7 (`C7: ¬P(x) ∨ Q(y) ∨ S(x,y)`)** is a binary relation `S(x,y)` clause with two universally quantified variables — it increases the number of pairwise combinations during grounding/resolution and so adds combinatorial complexity.
    
- **Clause 2a (`P(x) ∨ R(z)`)** by itself is simple, but because it involves two different variables `x` and `z` and interacts with other existential/skolem-derived facts, it participates in cross-instantiation that can blow up the search if there are many candidate ground terms.
    

So the primary complexity drivers: **Skolem functions** and **clauses with multiple universally quantified variables / predicate arities**.

---
## d
C6a:  Q(a)
C6b:  ¬U(a)

**Conclusion:** 
Yes

In the resolution proof above, the crucial starting fact was `Q(a)` (C6a). We used `Q(a)` to obtain `¬R(f4(a))` (via C4) which then allowed us to resolve `P(x) ∨ R(f4(a))` into `P(x)` (via C2a), and finally get `P(b)` to contradict `¬P(b)`.

If **clause 6 is removed**, we lose the _witness_ `a` with `Q(a)`. In that case:

- We can no longer instantiate `C4` with `x = a` to derive a particular `¬R(f4(a))`.
    
- Without any ground `Q(t)` fact, `C4` (which is `¬R(f4(x)) ∨ ¬Q(x)`) does not automatically give us a ground `¬R(...)` fact; it only says for each `x` either `¬R(f4(x))` or `¬Q(x)` holds, but without a concrete `Q(x)` we cannot force the `¬R(...)` disjunct.
    
- Therefore, the short refutation above fails: there is no guaranteed way to obtain a concrete `¬R(z0)` to feed into `C2a` and produce a universal `P(x)`.
    


